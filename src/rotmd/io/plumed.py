"""
PLUMED Integration for rotmd

Generate PLUMED input files for GROMACS enhanced sampling simulations
using protein orientation collective variables (φ, θ, ψ Euler angles).

PLUMED (Plugin for Molecular Dynamics) enables:
- Metadynamics (bias potential on CVs)
- Umbrella sampling
- Steered MD
- Free energy calculations

This module provides:
1. PLUMED input file (.dat) generation
2. Collective variable definitions for orientation angles
3. Integration with GROMACS MD simulations

Author: Mykyta Bobylyow
Date: 2025
"""

import numpy as np
from pathlib import Path
from typing import Optional, Dict, List, Tuple
from dataclasses import dataclass


@dataclass
class PlumedConfig:
    """
    Configuration for PLUMED input file generation.

    Attributes:
        protein_selection: Atom indices for protein (e.g., "1-1000")
        membrane_normal: Direction vector for membrane normal (default: [0,0,1] = z-axis)
        cv_names: List of CV names to include ['phi', 'theta', 'psi']
        output_stride: Print CVs every N steps
        metadynamics: Enable metadynamics biasing
        hills_height: Height of Gaussian hills (kJ/mol)
        hills_width: Width of Gaussian hills for each CV (degrees)
        hills_stride: Deposit hill every N steps
        wall_theta_min: Lower wall potential for theta (degrees)
        wall_theta_max: Upper wall potential for theta (degrees)
        wall_kappa: Wall force constant (kJ/mol/rad²)
    """

    protein_selection: str = "1-1000"
    membrane_normal: np.ndarray = None
    cv_names: List[str] = None
    output_stride: int = 100
    metadynamics: bool = False
    hills_height: float = 1.2  # kJ/mol
    hills_width: Dict[str, float] = None  # degrees
    hills_stride: int = 500
    wall_theta_min: Optional[float] = None
    wall_theta_max: Optional[float] = None
    wall_kappa: float = 150.0  # kJ/mol/rad²

    def __post_init__(self):
        if self.membrane_normal is None:
            self.membrane_normal = np.array([0.0, 0.0, 1.0])
        if self.cv_names is None:
            self.cv_names = ["theta", "psi"]  # Most common for membrane proteins
        if self.hills_width is None:
            self.hills_width = {"phi": 10.0, "theta": 5.0, "psi": 10.0}


class PlumedWriter:
    """
    Generate PLUMED input files for protein orientation CVs.

    PLUMED Strategy:
    ----------------
    Since PLUMED doesn't have built-in Euler angle CVs for rigid bodies,
    we use a combination of:

    1. **GYRATION**: Compute principal axes from gyration tensor
    2. **MATHEVAL**: Calculate orientation angles from principal axes
    3. **Custom CVs**: Define φ, θ, ψ based on rotation matrices

    The implementation uses:
    - Moment of inertia tensor → principal axes (eigenvectors)
    - Euler angles from ZYZ convention
    - Projection onto membrane normal for θ (tilt angle)
    """

    def __init__(self, config: PlumedConfig):
        self.config = config

    def generate_plumed_input(self, output_path: str):
        """
        Generate complete PLUMED input file.

        Args:
            output_path: Path to output plumed.dat file
        """
        lines = []

        # Header
        lines.extend(self._generate_header())

        # Define protein group
        lines.extend(self._generate_group_definition())

        # Compute center of mass
        lines.extend(self._generate_com_definition())

        # Compute gyration tensor (for principal axes)
        lines.extend(self._generate_gyration_definition())

        # Compute orientation angles
        lines.extend(self._generate_orientation_cvs())

        # Optional: Metadynamics
        if self.config.metadynamics:
            lines.extend(self._generate_metadynamics())

        # Optional: Wall potentials
        if (
            self.config.wall_theta_min is not None
            or self.config.wall_theta_max is not None
        ):
            lines.extend(self._generate_walls())

        # Print CVs
        lines.extend(self._generate_print_statement())

        # Footer
        lines.append("\n# End of PLUMED input\n")

        # Write to file
        with open(output_path, "w") as f:
            f.write("\n".join(lines))

        print(f"✓ PLUMED input file written to {output_path}")

    def _generate_header(self) -> List[str]:
        """Generate file header with metadata."""
        return [
            "# PLUMED input file for protein orientation analysis",
            "# Generated by rotmd",
            "# https://github.com/yourusername/rotmd",
            "#",
            "# Collective variables: " + ", ".join(self.config.cv_names),
            "# Membrane normal: " + str(self.config.membrane_normal.tolist()),
            "#",
            "# PLUMED version: 2.8+",
            "# Units: nm, ps, kJ/mol, degrees",
            "",
            "# Restart handling",
            "RESTART",
            "",
        ]

    def _generate_group_definition(self) -> List[str]:
        """Define atom group for protein."""
        return [
            "# Define protein atom group",
            f"protein: GROUP ATOMS={self.config.protein_selection}",
            "",
        ]

    def _generate_com_definition(self) -> List[str]:
        """Compute center of mass."""
        return ["# Compute center of mass", "com: COM ATOMS=protein", ""]

    def _generate_gyration_definition(self) -> List[str]:
        """
        Compute gyration tensor to extract principal axes.

        Note: PLUMED's GYRATION gives gyration tensor (similar to inertia tensor).
        We can extract principal axes from its eigenvectors.
        """
        return [
            "# Compute gyration tensor for principal axes",
            "gyration: GYRATION ATOMS=protein TYPE=GTPC_VECTOR",
            "",
            "# Extract principal components (gyration eigenvalues)",
            "gyr_eig: GYRATION ATOMS=protein TYPE=GTPC",
            "",
        ]

    def _generate_orientation_cvs(self) -> List[str]:
        """
        Generate orientation CV definitions.

        Strategy:
        ---------
        For membrane proteins, the most important angle is **theta (θ)**,
        the tilt angle relative to the membrane normal.

        We calculate θ using the dot product between the principal axis
        (longest axis, typically transmembrane helix) and membrane normal.

        θ = arccos(c_axis · membrane_normal)

        For full orientation, we also need φ and ψ, but these require
        more complex MATHEVAL expressions.
        """
        lines = [
            "# Define orientation collective variables",
            "#",
            "# Strategy: Use principal axes from gyration tensor",
            "# theta = tilt angle of principal axis relative to membrane normal",
            "",
        ]

        # For each CV
        if "theta" in self.config.cv_names:
            lines.extend(self._generate_theta_cv())

        if "psi" in self.config.cv_names:
            lines.extend(self._generate_psi_cv())

        if "phi" in self.config.cv_names:
            lines.extend(self._generate_phi_cv())

        return lines

    def _generate_theta_cv(self) -> List[str]:
        """
        Generate theta (tilt angle) CV definition.

        Theta is the angle between the protein's principal axis (c-axis)
        and the membrane normal (typically z-axis).

        Implementation:
        1. Define two dummy atoms along membrane normal
        2. Compute vector between them
        3. Use ANGLE or DISTANCE to get tilt

        Alternative: Use MATHEVAL with positions
        """
        mem_norm = self.config.membrane_normal

        return [
            "# Theta: Tilt angle relative to membrane normal",
            "# Computed from principal axis orientation",
            "#",
            "# Method: Define reference vectors and compute angle",
            "",
            "# Principal axis (approximated by end-to-end vector for now)",
            "# TODO: Use custom PLUMED module for exact principal axes",
            "# For now, we use a simplified approach:",
            "",
            "# Define N-terminus and C-terminus groups (adjust atom ranges)",
            "nterm: COM ATOMS=1-50      # First residues",
            "cterm: COM ATOMS=950-1000  # Last residues",
            "",
            "# Principal axis approximation: vector from N to C terminus",
            "paxis: DISTANCE ATOMS=nterm,cterm COMPONENTS",
            "",
            "# Normalize to get unit vector (using MATHEVAL)",
            "paxis_norm: MATHEVAL ARG=paxis.x,paxis.y,paxis.z",
            f"    FUNC=sqrt(x*x+y*y+z*z) PERIODIC=NO",
            "",
            "# Dot product with membrane normal",
            f"# membrane_normal = [{mem_norm[0]:.3f}, {mem_norm[1]:.3f}, {mem_norm[2]:.3f}]",
            "dot_product: MATHEVAL ARG=paxis.x,paxis.y,paxis.z,paxis_norm",
            f"    FUNC=({mem_norm[0]}*x+{mem_norm[1]}*y+{mem_norm[2]}*z)/w",
            "    PERIODIC=NO",
            "",
            "# Theta = arccos(dot_product), converted to degrees",
            "theta: MATHEVAL ARG=dot_product",
            "    FUNC=acos(x)*57.2958  # 180/pi",
            "    PERIODIC=NO",
            "",
        ]

    def _generate_psi_cv(self) -> List[str]:
        """
        Generate psi (spin angle) CV definition.

        Psi is the rotation around the protein's own principal axis.
        This requires defining a reference point and measuring rotation.

        For membrane proteins, psi describes rotation around the
        transmembrane helix axis.
        """
        return [
            "# Psi: Spin angle around principal axis",
            "# (Simplified implementation)",
            "#",
            "# TODO: Full implementation requires rotation matrix analysis",
            "# For now, we use a dihedral-like approach",
            "",
            "# Define reference atoms for tracking rotation",
            "# (This is a placeholder - needs customization per system)",
            "ref1: COM ATOMS=100-120   # Reference group 1",
            "ref2: COM ATOMS=500-520   # Reference group 2",
            "",
            "# Compute angle in xy-plane (projection perpendicular to z)",
            "psi: MATHEVAL ARG=ref1.x,ref1.y,ref2.x,ref2.y",
            "    FUNC=atan2(y-w,x-z)*57.2958",
            "    PERIODIC=-180,180",
            "",
        ]

    def _generate_phi_cv(self) -> List[str]:
        """
        Generate phi (precession angle) CV definition.

        Phi is the rotation of the protein base around the membrane normal.
        """
        return [
            "# Phi: Precession angle around membrane normal",
            "# (Simplified implementation)",
            "#",
            "# Project COM onto xy-plane and measure angle from x-axis",
            "phi: MATHEVAL ARG=com.x,com.y",
            "    FUNC=atan2(y,x)*57.2958",
            "    PERIODIC=-180,180",
            "",
        ]

    def _generate_metadynamics(self) -> List[str]:
        """Generate metadynamics directive."""
        cvs = ",".join(self.config.cv_names)

        # Determine sigma values (widths in CV space)
        sigmas = ",".join(
            [str(self.config.hills_width.get(cv, 5.0)) for cv in self.config.cv_names]
        )

        return [
            "# Metadynamics bias on orientation CVs",
            f"METAD ...",
            f"    ARG={cvs}",
            f"    SIGMA={sigmas}",
            f"    HEIGHT={self.config.hills_height}",
            f"    PACE={self.config.hills_stride}",
            f"    TEMP=300.0",
            f"    BIASFACTOR=10",
            f"    FILE=HILLS",
            f"    GRID_MIN=-180,-180",
            f"    GRID_MAX=180,180",
            f"... METAD",
            "",
        ]

    def _generate_walls(self) -> List[str]:
        """Generate wall potentials to restrict theta range."""
        lines = ["# Wall potentials to restrict theta range", ""]

        if self.config.wall_theta_min is not None:
            lines.extend(
                [
                    f"# Lower wall at theta = {self.config.wall_theta_min}°",
                    f"LOWER_WALLS ...",
                    f"    ARG=theta",
                    f"    AT={self.config.wall_theta_min}",
                    f"    KAPPA={self.config.wall_kappa}",
                    f"    EXP=2",
                    f"    EPS=1.0",
                    f"    OFFSET=0.0",
                    f"... LOWER_WALLS",
                    "",
                ]
            )

        if self.config.wall_theta_max is not None:
            lines.extend(
                [
                    f"# Upper wall at theta = {self.config.wall_theta_max}°",
                    f"UPPER_WALLS ...",
                    f"    ARG=theta",
                    f"    AT={self.config.wall_theta_max}",
                    f"    KAPPA={self.config.wall_kappa}",
                    f"    EXP=2",
                    f"    EPS=1.0",
                    f"    OFFSET=0.0",
                    f"... UPPER_WALLS",
                    "",
                ]
            )

        return lines

    def _generate_print_statement(self) -> List[str]:
        """Generate PRINT directive for output."""
        cvs = ",".join(self.config.cv_names)

        return [
            "# Output collective variables to file",
            f"PRINT ...",
            f"    ARG={cvs}",
            f"    STRIDE={self.config.output_stride}",
            f"    FILE=COLVAR",
            f"    FMT=%12.6f",
            f"... PRINT",
            "",
        ]


def generate_plumed_input(
    output_path: str,
    protein_atoms: str = "1-1000",
    cv_names: Optional[List[str]] = None,
    metadynamics: bool = False,
    **kwargs,
) -> None:
    """
    High-level function to generate PLUMED input file.

    Args:
        output_path: Path to output plumed.dat file
        protein_atoms: Atom selection for protein (e.g., "1-1000")
        cv_names: List of CVs to include ['phi', 'theta', 'psi']
        metadynamics: Enable metadynamics biasing
        **kwargs: Additional PlumedConfig parameters

    Example:
        >>> from rotmd.io.plumed import generate_plumed_input
        >>>
        >>> # Basic usage
        >>> generate_plumed_input('plumed.dat', protein_atoms='1-500')
        >>>
        >>> # With metadynamics
        >>> generate_plumed_input(
        ...     'plumed_metad.dat',
        ...     protein_atoms='1-500',
        ...     cv_names=['theta', 'psi'],
        ...     metadynamics=True,
        ...     hills_height=1.5,
        ...     hills_stride=1000
        ... )
        >>>
        >>> # With wall potentials
        >>> generate_plumed_input(
        ...     'plumed_walls.dat',
        ...     protein_atoms='1-500',
        ...     wall_theta_min=20.0,
        ...     wall_theta_max=160.0
        ... )
    """
    config = PlumedConfig(
        protein_selection=protein_atoms,
        cv_names=cv_names,
        metadynamics=metadynamics,
        **kwargs,
    )

    writer = PlumedWriter(config)
    writer.generate_plumed_input(output_path)


def read_colvar_file(colvar_path: str) -> Dict[str, np.ndarray]:
    """
    Read PLUMED COLVAR output file.

    Args:
        colvar_path: Path to COLVAR file

    Returns:
        Dictionary with CV names as keys, values as numpy arrays

    Example:
        >>> data = read_colvar_file('COLVAR')
        >>> print(data['theta'].mean())
        45.2
    """
    data = {}

    with open(colvar_path, "r") as f:
        # Read header to get column names
        for line in f:
            if line.startswith("#! FIELDS"):
                fields = line.split()[2:]  # Skip '#!' and 'FIELDS'
                for field in fields:
                    data[field] = []
                break

        # Read data
        for line in f:
            if line.startswith("#"):
                continue
            values = list(map(float, line.split()))
            for i, field in enumerate(fields):
                data[field].append(values[i])

    # Convert to numpy arrays
    return {k: np.array(v) for k, v in data.items()}


__all__ = [
    "PlumedConfig",
    "PlumedWriter",
    "generate_plumed_input",
    "read_colvar_file",
]
